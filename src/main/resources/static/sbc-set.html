<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title data-i18n="title.sbc_set">FODDR | Detalhes do SBC</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="app-shell">
    <header class="app-header">
      <div class="brand">FODDR</div>
      <div class="header-actions">
        <nav class="nav-links">
          <a href="index.html" data-i18n="nav.calculator">Calculadora</a>
          <a href="sbc.html" data-i18n="nav.sbcs">SBCs</a>
        </nav>
        <div class="lang-switch">
          <span data-i18n="lang.label">Idioma</span>
          <select id="languageSelect" data-i18n-aria-label="lang.label">
            <option value="pt-BR" data-i18n="lang.pt">Português</option>
            <option value="en-US" data-i18n="lang.en">English</option>
          </select>
        </div>
      </div>
    </header>

    <main class="app-main">
      <section class="sbc-panel sbc-set-detail">
        <div class="catalog-header set-detail__header">
          <div>
            <p class="catalog-eyebrow" data-i18n="sbc.eyebrow">Squad Building Challenges</p>
            <h1 id="setTitle" data-i18n="set.heading">Detalhes do SBC</h1>
            <p id="setSubtitle" class="set-detail__subtitle" data-i18n="set.subtitle_loading">Carregando informações…</p>
          </div>
          <div class="set-detail__actions">
            <a href="sbc.html" class="catalog-refresh set-detail__back" data-i18n="set.back_catalog">← Voltar ao catálogo</a>
          </div>
        </div>

        <div class="set-detail__meta" id="setMeta"></div>

        <div class="catalog-content" id="setContent">
          <div class="catalog-empty catalog-empty--loading" data-i18n="set.loading_details">Carregando detalhes do set…</div>
        </div>

        <section class="set-resolver" id="setResolverSection">
          <div class="set-resolver__header">
            <div>
              <h2 data-i18n="set.resolve_title">Resolver este set</h2>
              <p data-i18n="set.resolve_desc">Informe sua forragem disponível e resolva automaticamente os desafios deste set.</p>
            </div>
          </div>

          <div class="grid-wrapper">
            <div class="grid-heading">
              <div>
                <h3 data-i18n="index.base_fodder_title">Forragem base</h3>
                <p data-i18n="index.base_fodder_desc">Atualize a quantidade de cartas disponíveis em cada OVR.</p>
              </div>
            </div>
            <div class="rating-grid" id="setRatingGrid"></div>
          </div>

          <div class="grid-wrapper grid-wrapper--totw">
            <div class="grid-heading">
              <div>
                <h3 data-i18n="index.totw_fodder_title">Forragem TOTW</h3>
                <p data-i18n="index.totw_fodder_desc">Opcionalmente informe cartas TOTW disponíveis.</p>
              </div>
              <span class="grid-heading__badge" data-i18n="common.optional">OPCIONAL</span>
            </div>
            <div class="rating-grid rating-grid--totw" id="setTotwGrid"></div>
          </div>

          <button type="button" id="resolverSetBtn" class="submit-button" data-i18n="set.resolve_button">Resolver SBC</button>

          <div class="resolver-status" id="resolverStatus">
            <span data-i18n="set.status_default">Informe a forragem e clique em "Resolver SBC".</span>
          </div>
        </section>

        <section class="results-section set-results">
          <div class="results-header">
            <h2 data-i18n="common.results_title">Resultados</h2>
            <p id="resolverResultado" class="results-status" data-i18n="set.results_prompt">
              Informe a forragem e clique em "Resolver SBC".
            </p>
          </div>
          <div class="results-shell">
            <button type="button" id="resultPrev" class="result-nav" data-i18n-aria-label="index.prev_squad" disabled>&lsaquo;</button>
            <div class="result-viewport">
              <div id="resultTrack" class="result-track"></div>
            </div>
            <button type="button" id="resultNext" class="result-nav" data-i18n-aria-label="index.next_squad" disabled>&rsaquo;</button>
          </div>
          <div id="resultPagination" class="result-pagination"></div>
          <div class="result-totals">
            <h3 data-i18n="common.totals_title">Totais por OVR</h3>
            <div id="resultTotals" class="totals-container">
              <p class="totals-empty" data-i18n="common.totals_empty">Nenhum total calculado ainda.</p>
            </div>
          </div>

          <div class="result-informs">
            <h3 data-i18n="common.informs_title">Informs usados</h3>
            <div id="resultInforms" class="totals-container">
              <p class="totals-empty" data-i18n="common.informs_empty">Nenhum Inform utilizado.</p>
            </div>
          </div>

          <div id="partialAlert" class="partial-alert is-hidden">
            <strong data-i18n="common.partial_title">Resultado parcial</strong>
            <p data-i18n="common.partial_desc">Não conseguimos completar todos os elencos. Veja abaixo as sugestões para montar o restante.</p>
          </div>

          <div id="faltantesWrapper" class="faltantes-wrapper is-hidden">
            <div class="faltantes-header">
              <h3 data-i18n="common.next_steps_title">Próximos passos</h3>
              <p data-i18n="common.next_steps_desc">Utilize as combinações sugeridas para concluir os elencos pendentes.</p>
            </div>
            <div class="faltantes-grid">
              <div class="faltante-column">
                <h4 data-i18n="common.suggestions_title">Sugestões completas</h4>
                <div id="faltantesLista" class="faltante-list">
                  <p class="totals-empty" data-i18n="common.pending_empty">Nenhum elenco pendente.</p>
                </div>
              </div>
              <div class="faltante-column">
                <h4 data-i18n="common.have_title">Tenho</h4>
                <div id="faltantesPositivo" class="faltante-list">
                  <p class="totals-empty" data-i18n="common.no_info">Nenhuma informação disponível.</p>
                </div>
              </div>
              <div class="faltante-column">
                <h4 data-i18n="common.missing_title">Falta</h4>
                <div id="faltantesNegativo" class="faltante-list">
                  <p class="totals-empty" data-i18n="common.no_info">Nenhuma informação disponível.</p>
                </div>
              </div>
            </div>
          </div>
        </section>
      </section>
    </main>
  </div>

  <script src="i18n.js"></script>
  <script>
    const params = new URLSearchParams(window.location.search);
    const setId = params.get("setId");
    const API_SETS = "/sbc-sets";
    const RATING_START = 79;
    const RATING_END = 93;
    const TOTAL_RATINGS = RATING_END - RATING_START + 1;
    const STORAGE_KEY_COMPLETED_PREFIX = "foddr_set_completed_";
    const DEFAULT_FORRAGEM = {
      79: 10,
      80: 10,
      81: 10,
      82: 10,
      83: 10,
      84: 10,
      85: 10,
      86: 10,
      87: 10,
      88: 10,
      89: 10,
      90: 10,
      91: 10,
      92: 10,
      93: 10
    };
    const DEFAULT_TOTW = {
      79: 0,
      80: 0,
      81: 0,
      82: 0,
      83: 0,
      84: 0,
      85: 0,
      86: 0,
      87: 0,
      88: 0,
      89: 0,
      90: 0,
      91: 0,
      92: 0,
      93: 0
    };
    const STORAGE_KEY_FORRAGEM = "foddr_forragem";
    const STORAGE_KEY_TOTW = "foddr_forragem_totw";

    const titleEl = document.getElementById("setTitle");
    const subtitleEl = document.getElementById("setSubtitle");
    const metaEl = document.getElementById("setMeta");
    const contentEl = document.getElementById("setContent");
    const setRatingGrid = document.getElementById("setRatingGrid");
    const setTotwGrid = document.getElementById("setTotwGrid");
    const resolverBtn = document.getElementById("resolverSetBtn");
    const resolverStatusEl = document.getElementById("resolverStatus");
    const resultadoBox = document.getElementById("resolverResultado");
    const resultTrack = document.getElementById("resultTrack");
    const resultPrev = document.getElementById("resultPrev");
    const resultNext = document.getElementById("resultNext");
    const resultPagination = document.getElementById("resultPagination");
    const resultTotals = document.getElementById("resultTotals");
    const resultInforms = document.getElementById("resultInforms");
    const partialAlert = document.getElementById("partialAlert");
    const faltantesWrapper = document.getElementById("faltantesWrapper");
    const faltantesLista = document.getElementById("faltantesLista");
    const faltantesPositivo = document.getElementById("faltantesPositivo");
    const faltantesNegativo = document.getElementById("faltantesNegativo");

    const forragemCounts = Array(TOTAL_RATINGS).fill(0);
    const forragemTotwCounts = Array(TOTAL_RATINGS).fill(0);
    const resultState = {
      currentIndex: 0,
      cards: []
    };
    const completedChallenges = new Set();

    const normalizeCounts = (counts) => {
      const normalized = Array(TOTAL_RATINGS).fill(0);
      if (!Array.isArray(counts)) return normalized;
      counts.forEach((value, index) => {
        if (index < normalized.length) {
          normalized[index] = Number(value) || 0;
        }
      });
      return normalized;
    };

    const loadStoredCounts = (key) => {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        return normalizeCounts(JSON.parse(raw));
      } catch (err) {
        return null;
      }
    };

    const persistCounts = (key, counts) => {
      localStorage.setItem(key, JSON.stringify(counts));
    };

    const getCompletedStorageKey = () => `${STORAGE_KEY_COMPLETED_PREFIX}${setId || "unknown"}`;

    const loadCompletedChallenges = () => {
      if (!setId) return;
      try {
        const raw = localStorage.getItem(getCompletedStorageKey());
        if (!raw) return;
        const values = JSON.parse(raw);
        if (!Array.isArray(values)) return;
        values.forEach((value) => {
          const numeric = Number(value);
          if (Number.isFinite(numeric)) {
            completedChallenges.add(numeric);
          }
        });
      } catch (err) {
        completedChallenges.clear();
      }
    };

    const persistCompletedChallenges = () => {
      if (!setId) return;
      localStorage.setItem(getCompletedStorageKey(), JSON.stringify(Array.from(completedChallenges)));
    };

    const formatPlayerCount = (value) =>
      value === 1 ? t("common.player_single") : t("common.player_multi", { count: value });

    const setPartialAlertVisible = (visible) => {
      if (!partialAlert) return;
      partialAlert.classList.toggle("is-hidden", !visible);
    };

    const showResultPlaceholder = (message) => {
      if (!resultTrack) return;
      resultTrack.innerHTML = "";
      const placeholder = document.createElement("div");
      placeholder.className = "composition-empty";
      placeholder.textContent = message;
      resultTrack.appendChild(placeholder);
      if (resultPagination) resultPagination.innerHTML = "";
      resultState.cards = [];
      resultState.currentIndex = 0;
      if (resultPrev) resultPrev.disabled = true;
      if (resultNext) resultNext.disabled = true;
      if (resultTrack) resultTrack.style.transform = "translateX(0)";
      renderTotals();
      renderInformsSummary();
      setPartialAlertVisible(false);
      renderFaltantesSection(null, false);
    };

    const updateNavigation = () => {
      const total = resultState.cards.length;
      if (resultPrev) resultPrev.disabled = total <= 1 || resultState.currentIndex === 0;
      if (resultNext) resultNext.disabled = total <= 1 || resultState.currentIndex === total - 1;
      if (resultTrack) {
        resultTrack.style.transform = `translateX(-${resultState.currentIndex * 100}%)`;
      }
    };

    const renderPagination = () => {
      if (!resultPagination) return;
      resultPagination.innerHTML = "";
      if (resultState.cards.length <= 1) return;
      resultState.cards.forEach((_, index) => {
        const dot = document.createElement("button");
        dot.type = "button";
        dot.className = `result-dot${index === resultState.currentIndex ? " is-active" : ""}`;
        dot.addEventListener("click", () => {
          resultState.currentIndex = index;
          updateNavigation();
          renderPagination();
        });
        resultPagination.appendChild(dot);
      });
    };

    const renderTotals = (totalCounts) => {
      if (!resultTotals) return;
      resultTotals.innerHTML = "";

      if (!Array.isArray(totalCounts) || totalCounts.length === 0) {
        const empty = document.createElement("p");
        empty.className = "totals-empty";
        empty.textContent = t("common.totals_empty");
        resultTotals.appendChild(empty);
        return;
      }

      const list = document.createElement("ul");
      list.className = "composition-list totals-list";
      let hasContent = false;

      totalCounts.forEach((count = 0, index) => {
        if (index >= TOTAL_RATINGS) return;
        if (!count) return;
        hasContent = true;
        const rating = RATING_START + index;
        const item = document.createElement("li");
        item.className = "composition-item totals-item";

        const ratingSpan = document.createElement("span");
        ratingSpan.textContent = t("common.ovr_label", { rating });

        const countSpan = document.createElement("span");
        countSpan.textContent = formatPlayerCount(count);

        item.append(ratingSpan, countSpan);
        list.appendChild(item);
      });

      if (!hasContent) {
        const empty = document.createElement("p");
        empty.className = "totals-empty";
        empty.textContent = t("common.totals_empty");
        resultTotals.appendChild(empty);
        return;
      }

      resultTotals.appendChild(list);
    };

    const renderInformsSummary = (informsList) => {
      if (!resultInforms) return;
      resultInforms.innerHTML = "";

      if (!Array.isArray(informsList) || informsList.length === 0) {
        const empty = document.createElement("p");
        empty.className = "totals-empty";
        empty.textContent = t("common.informs_empty");
        resultInforms.appendChild(empty);
        return;
      }

      const totals = Array(TOTAL_RATINGS).fill(0);
      let hasData = false;

      informsList.forEach((counts = []) => {
        if (!Array.isArray(counts)) return;
        counts.forEach((value, index) => {
          if (index >= TOTAL_RATINGS) return;
          const numeric = Number(value) || 0;
          if (numeric > 0) hasData = true;
          totals[index] += numeric;
        });
      });

      if (!hasData) {
        const empty = document.createElement("p");
        empty.className = "totals-empty";
        empty.textContent = t("common.informs_empty");
        resultInforms.appendChild(empty);
        return;
      }

      const list = document.createElement("ul");
      list.className = "composition-list totals-list";

      totals.forEach((count, index) => {
        if (!count) return;
        const rating = RATING_START + index;
        const item = document.createElement("li");
        item.className = "composition-item totals-item";

        const ratingSpan = document.createElement("span");
        ratingSpan.textContent = t("common.ovr_label", { rating });

        const countSpan = document.createElement("span");
        countSpan.textContent = count === 1
          ? t("common.inform_single")
          : t("common.inform_multi", { count });

        item.append(ratingSpan, countSpan);
        list.appendChild(item);
      });

      resultInforms.appendChild(list);
    };

    const buildCompositionList = (counts = []) => {
      const normalized = normalizeCounts(counts);
      const list = document.createElement("ul");
      list.className = "composition-list";
      let hasContent = false;

      normalized.forEach((count, index) => {
        if (!count) return;
        hasContent = true;
        const rating = RATING_START + index;
        const item = document.createElement("li");
        item.className = "composition-item";

        const ratingSpan = document.createElement("span");
        ratingSpan.textContent = t("common.ovr_label", { rating });

        const countSpan = document.createElement("span");
        countSpan.textContent = formatPlayerCount(count);

        item.append(ratingSpan, countSpan);
        list.appendChild(item);
      });

      if (!hasContent) {
        const empty = document.createElement("div");
        empty.className = "composition-empty";
        empty.textContent = t("common.no_player_for_squad");
        return empty;
      }

      return list;
    };

    const hasInformUsage = (counts = []) => {
      if (!Array.isArray(counts)) return false;
      return counts.some((value) => Number(value) > 0);
    };

    const buildInformsList = (counts = []) => {
      const normalized = normalizeCounts(counts);
      const list = document.createElement("ul");
      list.className = "composition-list";
      let hasContent = false;

      normalized.forEach((count, index) => {
        if (!count) return;
        hasContent = true;
        const rating = RATING_START + index;
        const item = document.createElement("li");
        item.className = "composition-item";

        const ratingSpan = document.createElement("span");
        ratingSpan.textContent = t("common.ovr_label", { rating });

        const countLabel = count === 1
          ? t("common.inform_single")
          : t("common.inform_multi", { count });
        const countSpan = document.createElement("span");
        countSpan.textContent = countLabel;

        item.append(ratingSpan, countSpan);
        list.appendChild(item);
      });

      if (!hasContent) {
        const empty = document.createElement("p");
        empty.className = "inform-empty";
        empty.textContent = t("common.informs_empty");
        return empty;
      }

      return list;
    };

    const createInformBlock = (counts) => {
      const block = document.createElement("div");
      block.className = "inform-block";

      const title = document.createElement("h4");
      title.textContent = t("common.informs_title");
      block.appendChild(title);

      if (!hasInformUsage(counts)) {
        const empty = document.createElement("p");
        empty.className = "inform-empty";
        empty.textContent = t("common.informs_empty");
        block.appendChild(empty);
        return block;
      }

      block.appendChild(buildInformsList(counts));
      return block;
    };

    const renderFaltantesColumn = (container, combos, labelPrefix) => {
      if (!container) return;
      container.innerHTML = "";

      if (!Array.isArray(combos) || combos.length === 0) {
        const empty = document.createElement("p");
        empty.className = "totals-empty";
        empty.textContent = t("common.no_data");
        container.appendChild(empty);
        return;
      }

      combos.forEach((counts, index) => {
        const card = document.createElement("article");
        card.className = "faltante-card";

        const title = document.createElement("h5");
        title.textContent = `${labelPrefix} ${index + 1}`;
        card.appendChild(title);

        card.appendChild(buildCompositionList(counts));
        container.appendChild(card);
      });
    };

    const renderFaltantesSection = (payload, shouldShow) => {
      if (!faltantesWrapper) return;

      const faltantes = payload && Array.isArray(payload?.elencosFaltantes) ? payload.elencosFaltantes : [];
      const positivos = payload && Array.isArray(payload?.elencosFaltantesPositivo) ? payload.elencosFaltantesPositivo : [];
      const negativos = payload && Array.isArray(payload?.elencosFaltantesNegativo) ? payload.elencosFaltantesNegativo : [];

      const hasData = shouldShow && (faltantes.length || positivos.length || negativos.length);
      faltantesWrapper.classList.toggle("is-hidden", !hasData);

      if (!hasData) {
        [faltantesLista, faltantesPositivo, faltantesNegativo].forEach((container) => {
          if (container) container.innerHTML = "";
        });
        return;
      }

      renderFaltantesColumn(faltantesLista, faltantes, t("common.suggestion_prefix"));
      renderFaltantesColumn(faltantesPositivo, positivos, t("common.have_prefix"));
      renderFaltantesColumn(faltantesNegativo, negativos, t("common.missing_prefix"));
    };

    const createResultCard = (counts, index, targetOvr, options = {}) => {
      const normalizedCounts = normalizeCounts(counts);
      const isPending = Boolean(options.isPending);
      const informsCounts = options.informs;
      const card = document.createElement("article");
      card.className = `result-card${isPending ? " result-card--pending" : ""}`;

      const title = document.createElement("h3");
      title.textContent = t("common.squad_label", { index: index + 1 });
      card.appendChild(title);

      const statusBadge = document.createElement("span");
      statusBadge.className = `result-status-badge ${isPending ? "is-warning" : "is-success"}`;
      statusBadge.textContent = isPending ? t("common.status_pending") : t("common.status_complete");
      card.appendChild(statusBadge);

      const metaContainer = document.createElement("div");
      metaContainer.className = "result-meta";

      const totalPlayers = normalizedCounts.reduce((acc, value) => acc + value, 0);
      const weightedSum = normalizedCounts.reduce((acc, value, pos) => acc + value * (RATING_START + pos), 0);
      const average = totalPlayers ? (weightedSum / totalPlayers).toFixed(1) : "0.0";

      const firstRating = (() => {
        for (let i = 0; i < normalizedCounts.length; i++) {
          if (normalizedCounts[i]) return RATING_START + i;
        }
        return "--";
      })();

      const lastRating = (() => {
        for (let i = normalizedCounts.length - 1; i >= 0; i--) {
          if (normalizedCounts[i]) return RATING_START + i;
        }
        return "--";
      })();

      const targetLabel = Number.isFinite(targetOvr)
        ? t("common.target_ovr", { ovr: targetOvr })
        : t("common.avg_ovr", { ovr: average });
      const metaItems = [
        formatPlayerCount(totalPlayers),
        targetLabel,
        t("common.range_label", { start: firstRating, end: lastRating })
      ];

      metaItems.forEach((label) => {
        const badge = document.createElement("span");
        badge.className = "result-meta__item";
        badge.textContent = label;
        metaContainer.appendChild(badge);
      });

      card.appendChild(metaContainer);

      const composition = buildCompositionList(normalizedCounts);
      card.appendChild(composition);

      if (hasInformUsage(informsCounts)) {
        card.appendChild(createInformBlock(informsCounts));
      }

      return card;
    };

    const renderSolutions = (payload, ovrs = []) => {
      if (!resultadoBox) return;
      const elencos = payload && Array.isArray(payload.elencosCompletos) ? payload.elencosCompletos : [];
      const informs = payload && Array.isArray(payload.informsUsado) ? payload.informsUsado : [];
      const targetOvrs = (() => {
        const elencosResp = payload && payload.sbc && Array.isArray(payload.sbc.elencos) ? payload.sbc.elencos : [];
        if (!elencosResp.length) return ovrs;

        // Usa originalIndex do backend para manter o OVR na ordem correta
        return elencosResp
          .slice()
          .sort((a, b) => Number(a.originalIndex ?? 0) - Number(b.originalIndex ?? 0))
          .map((elenco) => {
            const valor = elenco.ovr ?? elenco.OVR;
            return Number.isFinite(Number(valor)) ? Number(valor) : undefined;
          });
      })();

      if (elencos.length === 0) {
        resultadoBox.textContent = t("common.no_complete_squads");
        showResultPlaceholder(t("common.no_squad_returned"));
        return;
      }

      if (resultTrack) resultTrack.innerHTML = "";
      resultState.cards = elencos.map((counts, index) =>
        createResultCard(counts, index, targetOvrs[index], {
          isPending: !Array.isArray(counts),
          informs: informs[index]
        })
      );
      resultState.cards.forEach((card) => resultTrack?.appendChild(card));
      resultState.currentIndex = 0;

      const completedCount = elencos.filter((counts) => Array.isArray(counts)).length;
      const hasPending = completedCount !== elencos.length;
      resultadoBox.textContent = hasPending
        ? t("common.partial_summary", { completed: completedCount, total: elencos.length })
        : t("common.complete_squads_found", { count: resultState.cards.length });

      updateNavigation();
      renderPagination();

      const totals = (() => {
        if (payload && Array.isArray(payload.total) && payload.total.length) {
          return normalizeCounts(payload.total);
        }
        return elencos.reduce((acc, counts) => {
          if (!Array.isArray(counts)) return acc;
          counts.forEach((value, index) => {
            if (index < acc.length) acc[index] += Number(value) || 0;
          });
          return acc;
        }, Array(TOTAL_RATINGS).fill(0));
      })();

      renderTotals(totals);
      renderInformsSummary(informs);
      setPartialAlertVisible(hasPending);
      renderFaltantesSection(payload, hasPending);
    };

    const goToPage = (index) => {
      if (index < 0 || index >= resultState.cards.length) return;
      resultState.currentIndex = index;
      updateNavigation();
      renderPagination();
    };

    resultPrev?.addEventListener("click", () => {
      goToPage(resultState.currentIndex - 1);
    });

    resultNext?.addEventListener("click", () => {
      goToPage(resultState.currentIndex + 1);
    });

    const extractTargetOvrs = (payload) => {
      const elencos = payload?.sbc?.elencos;
      if (!Array.isArray(elencos)) return [];
      return elencos.map((item) => {
        const value = item?.ovr ?? item?.OVR ?? item?.Ovr ?? item?.ovR;
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : undefined;
      });
    };

    const formatDate = (timestamp) => {
      if (!timestamp) return t("sbc.card_no_date");
      const date = new Date(Number(timestamp) * 1000);
      if (Number.isNaN(date.getTime())) return t("sbc.card_no_date");
      const locale = getCurrentLocale() || "pt-BR";
      return date.toLocaleDateString(locale, {
        day: "2-digit",
        month: "short",
        hour: "2-digit",
        minute: "2-digit"
      });
    };

    const formatFormation = (formation) => {
      if (!formation) return "—";
      if (typeof formation !== "string") return String(formation);
      if (formation.includes("-")) return formation;
      const trimmed = formation.trim();
      const match = trimmed.match(/^f(\d{3,4})[a-z]?$/i);
      if (!match) return trimmed;
      return match[1].split("").join("-");
    };

    const showMessage = (message, variant = "muted") => {
      contentEl.innerHTML = "";
      const box = document.createElement("div");
      const classes = ["catalog-empty"];
      if (variant) classes.push(`catalog-empty--${variant}`);
      box.className = classes.join(" ");
      box.textContent = message;
      contentEl.appendChild(box);
    };

    const createGridColumn = (rating) => {
      const column = document.createElement("div");
      column.className = "rating-col";
      column.dataset.rating = rating;

      const ratingCell = document.createElement("div");
      ratingCell.className = "cell cell-rating";
      ratingCell.textContent = rating;

      const plusButton = document.createElement("button");
      plusButton.type = "button";
      plusButton.className = "cell cell-plus";
      plusButton.dataset.action = "plus";
      plusButton.textContent = "+";

      const valueCell = document.createElement("div");
      valueCell.className = "cell cell-value";
      valueCell.textContent = "0";

      const minusButton = document.createElement("button");
      minusButton.type = "button";
      minusButton.className = "cell cell-minus";
      minusButton.dataset.action = "minus";
      minusButton.textContent = "-";

      column.append(ratingCell, plusButton, valueCell, minusButton);
      return column;
    };

    const renderRatingGrid = (gridEl) => {
      if (!gridEl) return;
      gridEl.innerHTML = "";
      for (let rating = RATING_START; rating <= RATING_END; rating++) {
        gridEl.appendChild(createGridColumn(rating));
      }
    };

    const updateGridValue = (gridEl, rating, value) => {
      if (!gridEl) return;
      const valueCell = gridEl.querySelector(`.rating-col[data-rating="${rating}"] .cell-value`);
      if (valueCell) {
        valueCell.textContent = value;
      }
    };

    const handleGridClick = (event, gridEl, counts) => {
      const button = event.target.closest("button[data-action]");
      if (!button) return;
      const column = button.closest(".rating-col");
      if (!column) return;
      const rating = Number(column.dataset.rating);
      if (Number.isNaN(rating)) return;

      const index = rating - RATING_START;
      if (index < 0 || index >= counts.length) return;

      const delta = button.dataset.action === "plus" ? 1 : -1;
      const nextValue = Math.max(0, (counts[index] || 0) + delta);
      counts[index] = nextValue;
      updateGridValue(gridEl, rating, nextValue);
      if (gridEl === setRatingGrid) {
        persistCounts(STORAGE_KEY_FORRAGEM, counts);
      } else if (gridEl === setTotwGrid) {
        persistCounts(STORAGE_KEY_TOTW, counts);
      }
    };

    const applyDefaultsToGrid = (gridEl, counts, defaultsMap) => {
      if (!gridEl || !defaultsMap) return;
      Object.entries(defaultsMap).forEach(([ratingStr, value]) => {
        const rating = Number(ratingStr);
        const index = rating - RATING_START;
        if (Number.isNaN(rating) || index < 0 || index >= counts.length) return;
        counts[index] = Number(value) || 0;
        updateGridValue(gridEl, rating, counts[index]);
      });
    };

    const applyCountsToGrid = (gridEl, counts) => {
      if (!gridEl) return;
      counts.forEach((value, index) => {
        const rating = RATING_START + index;
        updateGridValue(gridEl, rating, value);
      });
    };

    const attachGridListeners = () => {
      if (setRatingGrid) {
        setRatingGrid.addEventListener("click", (event) =>
          handleGridClick(event, setRatingGrid, forragemCounts)
        );
      }
      if (setTotwGrid) {
        setTotwGrid.addEventListener("click", (event) =>
          handleGridClick(event, setTotwGrid, forragemTotwCounts)
        );
      }
    };

    const updateResolverStatus = (message, variant = "muted") => {
      if (!resolverStatusEl) return;
      resolverStatusEl.textContent = message;
      resolverStatusEl.classList.remove("is-error", "is-success", "is-loading");
      if (variant === "error") {
        resolverStatusEl.classList.add("is-error");
      } else if (variant === "loading") {
        resolverStatusEl.classList.add("is-loading");
      } else if (variant === "success") {
        resolverStatusEl.classList.add("is-success");
      }
    };

    const getPayloadCounts = (counts) => counts.slice(0, TOTAL_RATINGS);

    const resolverSet = async () => {
      if (!resolverBtn) return;
      if (!setId) {
        updateResolverStatus(t("set.not_informed"), "error");
        return;
      }

      try {
        resolverBtn.disabled = true;
        updateResolverStatus(t("set.resolving"), "loading");
        if (resultadoBox) resultadoBox.textContent = t("common.loading");
        showResultPlaceholder(t("common.loading_squads"));

        const response = await fetch(`${API_SETS}/${encodeURIComponent(setId)}/resolver`, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            forragem: getPayloadCounts(forragemCounts),
            forragemTotw: getPayloadCounts(forragemTotwCounts),
            completedChallengeIds: Array.from(completedChallenges)
          })
        });

        if (!response.ok) {
          throw new Error(t("common.error_response", { status: response.status }));
        }

        const data = await response.json();
        renderSolutions(data, extractTargetOvrs(data));
        const totalElencos = Array.isArray(data?.elencosCompletos) ? data.elencosCompletos.length : 0;
        updateResolverStatus(t("set.resolved", { count: totalElencos }), "success");
      } catch (error) {
        console.error("Erro ao resolver set:", error);
        updateResolverStatus(t("set.resolve_error_retry"), "error");
        if (resultadoBox) {
          resultadoBox.textContent = t("set.error_loading_squads");
        }
        showResultPlaceholder(t("common.error_loading_squads"));
      } finally {
        if (resolverBtn) {
          resolverBtn.disabled = false;
        }
      }
    };

    const createMetaBadge = (label, value) => {
      const item = document.createElement("div");
      item.className = "set-meta-badge";

      const labelSpan = document.createElement("span");
      labelSpan.className = "set-meta-badge__label";
      labelSpan.textContent = label;

      const valueSpan = document.createElement("span");
      valueSpan.className = "set-meta-badge__value";
      valueSpan.textContent = value;

      item.append(labelSpan, valueSpan);
      return item;
    };

    const renderMeta = (set) => {
      metaEl.innerHTML = "";
      metaEl.appendChild(createMetaBadge(t("set.meta_expires"), formatDate(set.expiresAt)));
    };

    const renderRequirements = (requirements = []) => {
      if (!requirements.length) {
        const emptyReq = document.createElement("li");
        emptyReq.textContent = t("set.requirements_none");
        return [emptyReq];
      }

      const formatNamedCount = (name, count) => {
        const numericCount = Number(count);
        const safeCount = Number.isFinite(numericCount) && numericCount > 0 ? numericCount : 1;
        return name
          ? t("set.requirement_named_count", { name, count: safeCount })
          : t("set.requirement_count_only", { count: safeCount });
      };

      const createRequirementItem = (label, value) => {
        const item = document.createElement("li");
        item.className = "set-requirement";

        const header = document.createElement("div");
        header.className = "set-requirement__header";
        header.textContent = label;

        const details = document.createElement("div");
        details.className = "set-requirement__details";
        details.textContent = value;

        item.append(header, details);
        return item;
      };

      const items = [];
      const ratingReqs = requirements.filter(
        (req) => req.type === "TEAM_RATING_1_TO_100" && req.eligibilityValue != null
      );
      ratingReqs.forEach((req) => {
        items.push(createRequirementItem(t("set.requirement_team_rating"), String(req.eligibilityValue)));
      });

      const nationReqs = requirements.filter((req) => req.nationId != null);
      nationReqs.forEach((req) => {
        items.push(
          createRequirementItem(
            t("set.requirement_nation_label"),
            formatNamedCount(req.nationName, req.eligibilityValue)
          )
        );
      });

      const clubReqs = requirements.filter((req) => req.clubId != null);
      clubReqs.forEach((req) => {
        items.push(
          createRequirementItem(
            t("set.requirement_club_label"),
            formatNamedCount(req.clubName, req.eligibilityValue)
          )
        );
      });

      const leagueReqs = requirements.filter((req) => req.leagueId != null);
      leagueReqs.forEach((req) => {
        items.push(
          createRequirementItem(
            t("set.requirement_league_label"),
            formatNamedCount(req.leagueName, req.eligibilityValue)
          )
        );
      });

      if (!items.length) {
        const emptyReq = document.createElement("li");
        emptyReq.textContent = t("set.requirements_none");
        return [emptyReq];
      }

      return items;
    };

    const renderChallenge = (challenge) => {
      const card = document.createElement("article");
      card.className = "catalog-card challenge-card";

      const header = document.createElement("div");
      header.className = "challenge-card__header";

      const title = document.createElement("h3");
      title.className = "catalog-card__title";
      title.textContent = challenge.name || t("set.challenge", { id: challenge.challengeId });

      const repeatable = document.createElement("span");
      repeatable.className = `challenge-card__tag ${challenge.repeatable ? "is-repeatable" : ""}`;
      repeatable.textContent = challenge.repeatable ? t("set.challenge_repeatable") : t("set.challenge_single");

      const toggleLabel = document.createElement("label");
      toggleLabel.className = "challenge-card__toggle";

      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "challenge-card__checkbox";
      checkbox.value = String(challenge.challengeId ?? "");
      checkbox.checked = completedChallenges.has(Number(challenge.challengeId));

      const checkmark = document.createElement("span");
      checkmark.className = "challenge-card__checkmark";
      checkmark.setAttribute("aria-hidden", "true");
      checkmark.textContent = "✓";

      const labelText = document.createElement("span");
      labelText.className = "challenge-card__label";
      labelText.textContent = t("set.challenge_completed");

      toggleLabel.append(checkbox, checkmark, labelText);

      if (checkbox.checked) {
        card.classList.add("is-complete");
      }

      checkbox.addEventListener("change", () => {
        const challengeId = Number(challenge.challengeId);
        if (Number.isFinite(challengeId)) {
          if (checkbox.checked) {
            completedChallenges.add(challengeId);
          } else {
            completedChallenges.delete(challengeId);
          }
          persistCompletedChallenges();
        }
        card.classList.toggle("is-complete", checkbox.checked);
      });

      header.append(title, repeatable, toggleLabel);
      card.appendChild(header);

      const meta = document.createElement("ul");
      meta.className = "catalog-card__meta";

      const formationRow = document.createElement("li");
      formationRow.className = "catalog-card__meta-item";
      formationRow.innerHTML = `<span class="catalog-card__meta-label">${t("set.meta_formation")}</span><span class="catalog-card__meta-value">${formatFormation(challenge.formation)}</span>`;

      const expiresRow = document.createElement("li");
      expiresRow.className = "catalog-card__meta-item";
      expiresRow.innerHTML = `<span class="catalog-card__meta-label">${t("set.meta_expires")}</span><span class="catalog-card__meta-value">${formatDate(challenge.expiresAt)}</span>`;

      meta.append(formationRow, expiresRow);
      card.appendChild(meta);

      const reqList = document.createElement("ul");
      reqList.className = "set-requirements";
      renderRequirements(challenge.requirements).forEach((req) => reqList.appendChild(req));
      card.appendChild(reqList);

      return card;
    };

    const renderChallenges = (challenges = []) => {
      contentEl.innerHTML = "";
      if (!challenges.length) {
        showMessage(t("set.no_challenges"), "muted");
        return;
      }

      const grid = document.createElement("div");
      grid.className = "catalog-grid";
      challenges.forEach((challenge) => grid.appendChild(renderChallenge(challenge)));
      contentEl.appendChild(grid);
    };

    const renderSet = (set) => {
      titleEl.textContent = set.name || t("set.untitled");
      subtitleEl.textContent = set.categoryName
        ? t("set.category_label", { name: set.categoryName })
        : t("set.category_unknown_detail");
      renderMeta(set);
      renderChallenges(set.challenges);
    };

    const carregarSet = async () => {
      if (!setId) {
        showMessage(t("set.not_informed_detail"), "error");
        subtitleEl.textContent = t("set.id_missing");
        return;
      }

      showMessage(t("set.loading_details"), "loading");

      try {
        const response = await fetch(`${API_SETS}/${encodeURIComponent(setId)}`, {
          headers: { Accept: "application/json" }
        });

        if (!response.ok) {
          throw new Error(t("common.error_response", { status: response.status }));
        }

        const data = await response.json();
        renderSet(data);
      } catch (error) {
        console.error("Erro ao carregar set:", error);
        showMessage(t("set.load_details_error"), "error");
        subtitleEl.textContent = t("set.error_loading_data");
      }
    };

    const inicializarResolver = () => {
      loadCompletedChallenges();
      renderRatingGrid(setRatingGrid);
      renderRatingGrid(setTotwGrid);
      applyDefaultsToGrid(setRatingGrid, forragemCounts, DEFAULT_FORRAGEM);
      applyDefaultsToGrid(setTotwGrid, forragemTotwCounts, DEFAULT_TOTW);
      const storedForragem = loadStoredCounts(STORAGE_KEY_FORRAGEM);
      if (storedForragem) {
        storedForragem.forEach((value, index) => {
          forragemCounts[index] = value;
        });
        applyCountsToGrid(setRatingGrid, forragemCounts);
      }
      const storedTotw = loadStoredCounts(STORAGE_KEY_TOTW);
      if (storedTotw) {
        storedTotw.forEach((value, index) => {
          forragemTotwCounts[index] = value;
        });
        applyCountsToGrid(setTotwGrid, forragemTotwCounts);
      }
      attachGridListeners();
      if (resolverBtn) {
        resolverBtn.addEventListener("click", resolverSet);
      }
    };

    showResultPlaceholder(t("common.no_squad_loaded"));
    inicializarResolver();
    carregarSet();
  </script>
</body>
</html>
